---
published : true
layout : post
categories : DB, sql
title : 데이터 모델과 성능
tags : [DB, sql]
date-string : May 04, 2024
---

# 데이터 모델과 성능
## 성능 데이터 모델링 개요
### 성능 데이터 모델링
- 목적 : 데이터베이스의 성능 향상
- 데이터 모델 설계 시점부터 정규화, 반덩규화, 테이블 통합, 테이블 분할, 조인 구조, PK, FK 등 여러가지 성능과 관련된 사항들이 데이터 모델링 작업에 반영될 수 있도록 하는 것

### 성능 데이터 모델링 수행 시점
- 분석/설계 단계부터
  - 성능 저하에 따른 비용 최소화 가능

### 성능 데이터 모델링 고려사항
- 데이터 모델링 시 정규화 작업을 수행
- 데이터베이스의 용량을 산정
- 데이터베이스에 발생되는 트랜잭션의 유형 파악
- 데이터베이스 용량 및 트랜잭션의 유형에 따라 반정규화 수행
- 이력 데이터 모델의 조정, PK.FK 조정, 슈퍼/서브 타입 변환 조정 등을 수행
- 성능 관점에서 데이터 모델 검증

#### 데이터 모델링 시 정규화를 완벽하게 수행해야함
- 정규화된 모델은 주요 관심사별로 데이터를 분산시키는 효과
  - 그 자체로도 성능 향상

## 정규화와 성능
### 정규화를 통한 성능 향상 전략
- 정규화를 수행 -> 결정자에 의해 함수적 종속을 가지고 있는 일반 속성을 의존자로 하여 입력/수정/삭제 이상현상을 제거
- 정규화 작업
  - 데이터의 중복 속성 제거
  - 결정자에 의해 동일한 의미의 일반 속성이 하나의 테이블로 집약
    - 한 테이블의 데이터 용량 최소화

### 정규화 용어

|용어|설명|
|-------------|----------------------------------------------------|
|정규화|관계형 데이터베이스 테이블의 삽입/삭제/갱신 이상현상 발생을 최소화하기 위해 좀 더 작은 단위의 테이블로 설계하는 과정|
|정규형|정규화한 결과|
|함수적 종속|테이블의 특정 칼럼 A의 값을 알면 다른 칼럼 B값을 알 수 있을 때 칼럼 B는 칼럼 A에 함수적 종속성이 있다고 함|
|결정자|위의 설명에서 A를 결정자|
|다치종속|결정자 칼럼에 의해 칼럼 B의 값을 다수 개 알 수 있을 때 칼럼 B는 A에 다치종속되었다고 함|

### 정규화 효과 및 장점
- 상호 종속성이 강한 데이터 요소들을 분리, 독립된 개념으로 정의
  - 높은 응집도 & 낮은 결합도 원칙에 충실
    - 유연성 극대화
- 정규화를 통해 개념이 좀 더 세분화됨
  - 해당 개념에 대한 재활용 가능서 ㅇ증가
- 중복 최소화
  - 데이터 품질 확보
  - 저장공간 절약
  - DML 처리 시 성능 향상

### 정규화 이론
- 1, 2, 3, 보이스-코드 정규화는 함수 종속성에 근거하여 정규화 수행
- 4차 정규화는 다치종속에 근거하여 정규화 수행
- 5차 정규화는 조인에 의해 발생하는 이상현상제거로 정규화수행

|정규화 유형|설명|
|----------|--------------------------------------------|
|1차 정규화|한 속성에 여러 개의 속성값을 갖거나 같은 유형의 속성이 여러개인 경우 해당 속성을 분리시킨다 <br> 1차 정규화 작업으로 속성의 원자성 확보|
|2차 정규화|주식별자에 완전 함수 종속되지 않은 속성을 분리 <br> 2차 정규화 작업으로 부분 종속 속성이 된 속성을 분리|
|3차 정규화|일반 속성끼리 함수 종속이 발생한 속성을 분리 <br> 3차 정규화 작업으로 이행적 종속 속성을 분리|
|보이스-코드 정규화|결정자 안에 함수 종속을 가진 주식별자 속성을 분리|
|4차 정규화|다가 종속 속성을 별도의 엔터티로 분리|
|5차 정규화|결합 종속일 경우는 2개 이상의 엔터티로 분리|

- 일반적으로 3차 정규화까지 진행

### 제1정규형
- 한 속성에 여러 개의 속성값을 갖거나 같은 유형의 속성이 여러 개인 겨우 해당 속성을 분리시켜야 함

### 제2정규형
- 제1정규형을 만족하고 모든 PK가 아닌 칼럼은 OK전체에 종속되어야 함
- PK에 종속적이지 않거나 PK중 일부 칼럼들에만 종속적인 칼럼은 분리되어야함

### 제3정규형
- 제2정규형을 만족하고 일반 속성들 간에도 함수 종속 관계가 존재하지 않아야 함
- 일반 속성들 간 종속 관계가 존재하는 것들은 분리되어야함

### 정규화와 성능
- 전에 없었던 조인이 발생하게 되더라도 효율적인 인덱스 사용을 통해 조인 연산을 수행하면 성능상읜 단점은 거의 없음
- 적은 용량의 테이블이 생성된다면 조인 연산 시 적은 용량의 테이블을 먼저 읽어 조인을 수행하면 됨 -> 성능 상 유리
- 정규화가 제대로 되지 않으면 비슷한 종류의 속성이 여러 개가 되어 과도하게 많은 인덱스가 만들어질 수 있다.

## 반정규화와 성능
### 반정규화의 정의
- 반정규화 : 정규화된 데이터 모델을 분석하여 엔터티/속성/관계를 중복, 통합, 분리 등의 작업으로 수행하는 데이터 모델링 기법
- 일반적으로 데이터를 고의적으로 중복 저장하여 조회 성능을 향상시키기 위한 기법(조인 연산 회피)
- 더 넓은 의미 : 조회 성능을 향상시키기 위해 정규화된 데이터 모델에서 중복, 통합, 분리 등을 수행하는 모든 과정
- 수행하는 경우
  - 조회할 때 디스크 I/O량이 많아서 성능이 저하되는 경우
  - 테이블 간 경로가 너무 멀어 조인으로 인한 성능 저하가 예상되는 경우
  - 칼럼을 계산하여 읽을 때 성능이 저하될 것이 예상되는 경우

### 반정규화의 절차
- 반정규화 대상 조사
  - 범위 처리 빈도수 조사
  - 대량의 범위 처리 조사
  - 통계성 프로세스 조사
  - 테이블 조인 개수

- 다른 방법 유도 검토
  - 뷰 테이블
  - 클러스터링 적용
  - 인덱스의 조정
  - 응용 애플리케이션 변경

- 반정규화 적용
  - 테이블 반정규화
  - 속성의 반정규화
  - 관계의 반정규화

### 반정규화 기법


- 테이블 반정규화 기법
  - 테이블 병합
    - 1:1 관계 테이블 병합
      - 1:1 관계를 통합하여 성능을 향상시키는 방법
      - 2개의 테이블을 하나의 테이블로 병합하여 테이블 간 조인 연산을 제거
    - 1:M 관계 테이블 병합
      - 1:M 관계를 통합하여 성능을 향상시키는 방법
      - 2개의 테이블을 하나의 테이블로 병합하여 테이블 간 조인 연산을 제거
    - 슈퍼/서브 타입 테이블 병합
      - 슈퍼/서브 관계를 통합하여 성능을 향상시키는 방법
      - 슈퍼/서브 타입 관계를 하나의 테이블로 병합하여 조인 연산을 제거

  - 테이블 분할
    - 수직 분할
      - 칼럼 단위의 테이블을 디스크 I/O 분산 처리하기 위해 테이블을 1:1로 분리하여 성능을 향상시키는 방법
      - 트랜잭션이 처리되는 유형 파악이 선행되어야 함
    - 수평 분할
      - 로우 단위로 집중 발생되는 트랜잭션을 분석하여 디스크 I/O 및 데이터 접근 효율을 높여 성능을 향상하기 위해 로우 단위로 테이블을 쪼개는 방법

  - 테이블 추가
    - 중복 테이블 추가
      - 다른 업무이거나 서버가 다른 경우 동일한 테이블 구조를 중복하여 원격 조인을 제거하여 성능을 향상시킨다
    - 통계 테이블 추가
      - SUM, AVG 등을 미리 수행하여 계산해둠으로써 조회 시 성능을 향상시킨다
    - 이력 테이블 추가
      - 이력 테이블 중에서 마스터 테이블에 존재하는 레코드를 중복하여 이력 테이블에 저장하는 반정규화 기법
    - 부분 테이블 추가
      - 특정 테이블에서 전체 칼럼 중 자주 이용하는 집중화된 칼럼들이 있을 때, 디스크 I/O를 줄이기 위해 해당 칼럼들을 모아놓은 별도의 반정규화된 테이블을 생성

- 칼럼 반정규화 기법

|기법|설명|
|----------------------|----------------------------------------------|
|중복 칼럼 추가|조인 연산으로 인한 성능 저하를 예방하기 위해 중복 칼럼을 추가하여 조인 연산을 하지 않도록 함|
|파생 칼럼 추가|트랜잭션이 처리되는 시점에 계산에 의해 발생되는 값의 성능 저하를 예방하기 위해 미리 값을 계산하여 칼럼에 보관|
|이력 테이블 칼럼 추가|대량의 이력 데이터를 처리할 때 불특정한 날 조회나 최근 값을 조회할 때 나타날 수 있는 성능 저하를 예방하기 위해 이력 테이블에 칼럼을 추가|
|PK에 의한 칼럼 추가|복합의비를 갖는 PK를 단일 속성으로 구성하였을 경우 단일PK 안에서 특정 값을 별도로 조회하는 경우 성능 저하가 발생할 수 있다 <br> 이때 이미 PK 안에 데이터가 존재하지만 성능 향상을 위해 일반 속성으로 생성하는 방법이 PK에 의한 칼럼 추가 반정규화|
|응용 시스템의 오작동을 위한 칼럼 추가|비즈니스적으로 의미가 없지만 사용자가 데이터 처리를 하다가 잘못 처리하여 원래의 값으로 복구를 원하는 경우 이전 데이터를 임시적으로 중복하여 보관하는 기법 <br> 칼럼으로 이것을 보관하는 방법은 오작동 처리를 위한 임시적인 기법, 이것을 이력 데이터 모델로 풀어내면 정상적인 데이터 모델의 기법이 될 수 있음|

- 관계 반정규화 기법
  - 중복 관계 추가
    - 데이터를 처리하기 위한 여러 경로를 거쳐 조인이 가능하지만, 이때 발생할 수 있는 성능 저하를 예방하기 위해 추가적인 관계를 맺는 방법이 관계의 반정규화

## 대량 데이터에 따른 성능
### 대량 데이터 발생에 따른 테이블 분할 개요
- 수평 분할은 행 단위로 분할하여 Input/Output(I/O)을 감소시키는 방법
- 수직 분할은 칼럼 단위로 분할하여 I/O를 감소시키는 방법
#### I/O
- 테이블 내에 모든 행은 블록 단위로 디스크에 저장
- 오라클 DBMS 기준 1개의 블록은 8192바이트. 하나의 블록마다 8192바이트를 저장, 그러한 블록이 모여서 테이블의 데이터를 이룸
- 칼럼이 많아지게 되면 하나의 행을 저장 시 물리적인 디스크에 여러 블록에 걸쳐 데이터가 저장될 가능성이 높아짐
- 특정 테이블에서 한 행의 용량이 8193바이트라고 가정하면 하나의 행을 읽더라도 2개의 블록을 읽게됨. 16384 바이트를 읽게되고 8191 바이트는 버려짐
- 성능 저하 발생

#### 대용량 테이블에서 발생할 수 있는 성능 저하 현상
- 성능 저하 현상
  - 로우 체이닝
    - 행 길이가 너무 길어서 2개 이상의 블록에 걸쳐 하나의 로우가 저장되어 있는 형태
  - 로우 마이그레이션
    - 데이터 블록에서 수정이 발생하면 수정된 데이터를 해당 데이터 블록에서 저장하지 못하고 다른 블록의 빈 공간을 찾아 저장하는 방식

#### 디스크I/O
- 특정 블록을 데이터베이스 내 메모리에서 찾을 수 없어서 디스크를 읽게 되는 상황
  - 고비용 작업 -> DBMS 성능의 급격한 저하를 유발

### 한 테이블에 많은 수의 칼럼을 가지는 경우의 성능 저하
- 한 테이블에 칼럼이 매우 많으면 SQL문이 실행될 때 마다 모든 칼럼을 읽게됨. 불필요한 블록 I/O의 수가 많아짐.-> DBMS 성능 저하
- 이 경우 테이블을 수직 분할하면 성능 향상 가능

#### 테이블 수직 분할
- 한 칼럼에 대한 트랜잭션이 독립적으로 발생되는 경우가 많으면 1:1 관계로 수직 분할
- 분리된 테이블은 칼럼의 수가 적어짐, 1개의 행을 읽기 위해서 절대적으로 읽어야 할 데이터 블록의 수가 줄어듬 -> 로우 마이그레이션과 로우 테이닝 현상 감소

### 한 테이블에 많은 수의 행을 가지는 경우의 성능 저하
- 한 테이블에 행의 수가 많음 -> SQL문의 성능이 저하될 수 있음
- 이 경우 수평 분할하여 성능을 향상시킬 수 있음
- 파티셔닝 : 수평분할
  - 범위 파티셔닝 : 특정 기간으로 분할하는 것
  - 리스트 파티셔닝 : 파티셔닝 할 항목을 관리자가 직접 골라서 파티셔닝
    - 데이터 보관 주기에 따라 쉽게 삭제하는 기능은 제공하기 어려움
  - 해시 파티셔닝
    - 지정된 HASH 조건에 따라 해싱 알고리즘을 적용하여 테이블을 분리
    - 각각의 해시 파티션에 분리되어 데이터가 입력됨
    - 관리자는 특정 데이터가 어떤 파티션에 저장되는지 정확하게 예측 불가능
    - 데이터 입력 시 경합에 의한 성능 부하를 해소
    - 데이터 보관 주기에 따라 쉽게 삭제하는 기능 제공 불가능

### 테이블에 대한 수평/수직 분할의 절차
- 데이터 모델링 완성
- 데이터베이스 용량 산정
- 대량의 데이터가 처리되는 테이블에 대해서 트랜잭션 처리 패턴을 분석
- 칼럼 단위로 집중화된 처리가 발생하는지, 로우 단위로 집중화된 처리가 발생되는지 분석하여 처리 작업이 집중화된 단위로 테이블을 분리하는 것을 검토

## 데이터베이스 구조와 성능
### 슈퍼/서브 타입 모델
- 슈퍼/서브 타입 모델은 업무를 구성하는 데이터의 특징을 분석하여 공통점과 차이점을 고려하여 효과적으로 표현 가능
- 공통의 부분을 슈퍼 타입 엔터티로 도출, 다른 엔터티오 차이가 있는 속성에 대해서는 별도의 서브 타입 엔터티로 구분하는 방식
- 장점
  - 비즈니스의 모습을 정확하게 표현
  - 물리적인 데이터 모델로 변환할 때 선택의 폭을 넓힐 수 있음

- 슈퍼 서브 타입 모델 변환 방법
  - 슈퍼 타입
    - 슈퍼/서브 타입 모델을 하나의 테이블로 변환
    - Single 타입 기준 혹은 All in One 타입 기준이라고도 함
  - 서브 타입
    - 슈퍼/서브 타입을 섭 타입 테이블들로 변환한 것
    - 도출된 각각의 서브 타입에는 변환 전 슈퍼 엔터티에 있던 칼럼들을 공통적으로 가지고 있음
    - Plus 타입 기준 혹은 Super+Sub 타입 기준이라고도 함
  - 개별 타입
    - 슈퍼/서브 타입을 슈퍼 타입과 서브 타입의 각각 개별 테이블로 변환한 것
    - 슈퍼 테이블, 서브 테이블 모두 생성
    - OneToOne, 타입 기준 혹은 1:1 타입 기준이라고도 함

### 슈퍼/서브 타입 모델 변환의 중요성
- 트랜잭션은 항상 슈퍼 타입 기준으로 처리하는데 테이클은 개별 타입으로 유지되어 UNION 연산에 의해 성능이 저하될 수 있음(슈퍼타입 기준으로 테이블 구성 유리)
- 트랜잭션은 항상 서브 타입을 기준으로 처리하는데 슈퍼 타입으로 되어 있는 경우 성능이 저하되는 경우가 있음(서브 타입 기준으로 테이블 구성 유리)
- 트랜잭션은 항상 개별 타입 기준으로 처리하는데 테이블은 슈퍼 타입 기준으로 되어있어서 불필요하게 많은 양의 데이터가 집약되어 성능이 저하되는 경우(개별 타입으로 테이블을 구성하는 것이 유리)

### 슈퍼/서브 타입 변환 기법 비교

|구분|슈퍼 타입|서브 타입|개별 타입|
|---|-------|-------------|------------|
|특징|하나의 테이블|각각의 서브 타입 테이블|슈퍼, 서브 각각의 테이블|
|확장성|나쁨|보통|좋음|
|조인 성능|우수함|나쁨|나쁨|
|I/O 성능|나쁨|좋음|좋음|
|관리 용이성|좋음|좋지 않음|좋지 않음|
|트랜잭션 유형에 따른 선택 방법|전체를 일괄적으로 처리하는 경우 선택|각각의 서브 타입을 기준으로 처리하는 경우 선택|각각의 슈퍼, 서브 타입을 기준으로 처리하는 경우 선택|

### PK칼럼 순서와 성능
- 테이블에는 기본키(PK)가 존재. 단일PK일 수도 있고 복합PK일 수도 있음
- 복합PK인 경우 PK칼럼 순서에 따라 SQL문의 성능이 빨라질 수도 있고 느려질 수도 있음
  - 인구 테이블의 PK : 행정동코드, 기준년월, 인구구분코드, 연령대구분코드
  - 조회할 때 대부분 기준년월, 인구구분코드, 연령대구분코드로만 조건값을 줌
    - 맨 앞의 행정동코드 칼럼에 대해서는 조건값이 들어오지 않음 -> 테이블 풀 스캔 발생

- 논리 데이터 모델링 시 식별자(PK)가 여러 개의 속성으로 구성된 복합PK일 때 PK 순서에 대해 성능적으로 고민하지 않고 물리 데이터 모델에 그대로 적용 -> 비효율적인 복합PK의 칼럼 순서 -> 성능 저하

- 테이블 생성 시 PK는 DBMS에서 자동으로 인덱스도 같이 생성 -> PK가 복합PK인 경우 복합PK의 칼럼 순서가 성능에 영향을 미침


### 외래키(FK)칼럼에 대한 인덱스 생성의 중요성
- 논리 데이터 모델상으로 관계에 의한 외래키 제약이 걸린 경우, 해당 FK 제약이 실제 물리 데이터베이스에 적용될지는 물리 데이터 모델 설계자의 몫
- 관계가 있어도 FK 제약조건 미생성 경우 존재, FK 제약조건을 생성했더라도 해당 FK칼럼에 인덱스 미생성 경우 존재
- 물리적인 FK 생성 여부와는 상관없이 FK 제약조건이 있다면(관계가 있다면, 논리/물리 여부 상관없이) 외래키 칼럼에 대해 인덱스를 생성하는 것이 성능상 유리한 경우가 많음

## 분산 데이터베이스와 성능
### 분산 데이터베이스의 개요
- 논리적으로 동일한 시스템에 속함. 컴퓨터 네트워크를 통해 물리적으로 분산되어 있는 데이터들의 모임
  - 물리적 위치가 분산, 논리적으로는 여러 사용자가 공규 가능

## 분산 데이터베이스의 투명성
- 해당 데이터베이스를 사용하는 사용자가 데이터베이스 시스템이 분산되어 있는 것을 인식하지 못하고 자신만의 데이터베이스 시스템을 사용하는 것으로 인식하도록 만드는 것

|투명성|설명|
|-------|---------------------------------------|
|분할 투명성(단편화)|하나의 논리적 Relation(테이블)이 여러 단편으로 분할되어 각 단편의 사본이 여러 Site에 저장. 사용자는 한 곳에 위치하는 것으로 인식해야 함|
|위치 투명성|사용하려는 데이터의 저장 장소를 명시할 필요 없음. 위치정보가 System Catalog에 유지되어야 함|
|지역 사상 투명성|지역 DBMS와 물리적 DB 사이의 맵핑 보장|
|장애 투명성|구성요소의 장애에 무관한 트랜잭션의 원자성을 유지|
|병행 투명성|다수 트랜잭션이 동시에 수행 시 결과의 일관성을 유지|

### 분산 데이터베이스의 적용 방법
- 업무구성에 따른 아키텍처 특징에 따라 데이터베이스를 구성
  - 업무의 특징에 따라 데이터베이스 분산구조를 선택적으로 설계하는 능력이 필요

### 분산 데이터베이스의 장단점
- 장점
  - 지역자치성, 점증적 시스템 용량 확장
  - 신뢰성과 가용성
  - 효용성과 융통성
  - 빠른 응답 속도와 통신비용 절감
  - 데이터의 가용성과 신뢰성 증가
  - 시스템 규모의 적절한 조절
  - 각 지역 사용자의 요구 수용 증대

- 단점
  - 소프트웨어 개발 비용
  - 오류의 잠재성 즈애
  - 처리 비용의 증대
  - 설계 및 관리의 복잡성과 비용
  - 불규칙한 응답 속도
  - 통제의 어려움
  - 데이터 부결성에 대한 위협

### 분산 데이터베이스의 적용 기법
- 테이블 위치(Location) 분산
  - 설계된 테이블의 위치를 각각 다르게 위치시키는 것
- 테이블 분할 분산
  - 각각의 테이블을 쪼개어 분산
  - 수평 분할 : 노드에 따라 테이블을 특정 칼럼의 값을 기준으로 행을 분리
  - 수직 분할 : 노드에 따라 테이블 칼럼을 기준으로 열을 분리, 행은 분리 안함

- 테이블 복제 분산
  - 동일한 테이블을 다른 지역이나 서버에서 동시에 생성하여 관리하는 유형
  - 부분복제 : 통합된 테이블을 한 군데에 가지고 있으면서 각 노드별로는 노드에 해당된 행을 가지고 있는 형태
  - 광역복제 : 통합된 테이블을 한 군데에 가지고 있으면서 각 노드에도 동일한 데이터를 모두 가지고 있는 형태

- 테이블 요약 분산
  - 지역 간에 또는 서버 간에 데이터가 비슷하지만 서로 다른 유형으로 존재
  - 분석요약 : 각 노드별로 존재하는 요약정보를 한 군데에 통합하여 다시 전체에 대해서 요약정보를 산출하는 분산방법
  - 통합요약 : 각 노드별로 존재하는 다른 내용의 정보를 한 군데에서 통합하여 다시 전체에 대해서 요약정보를 산출하는 분산방법